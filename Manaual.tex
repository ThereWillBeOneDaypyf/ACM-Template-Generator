
\documentclass[a4]{article}
\usepackage{xeCJK}
\usepackage{amsmath, amsthm}
\usepackage{listings,xcolor}
\usepackage{geometry}
\usepackage{fontspec}
\setsansfont{Monaco}
\setmonofont[Mapping={}]{Monaco}
\geometry{left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm}
\lstset{
    language    = c++,
    breaklines  = true,
    captionpos  = b,
    tabsize     = 4,
    columns     = fullflexible,
    commentstyle = \color[RGB]{0,128,0},
    keywordstyle = \color[RGB]{0,0,255},
    basicstyle   = \large\ttfamily,
    stringstyle  = \color[RGB]{148,0,209}\ttfamily,
    rulesepcolor = \color{red!20!green!20!blue!20},
    showstringspaces = false,
}
\title{ACM/ICPC Template Manaual}
\author{CSL}
\begin{document}\large
\begin{titlepage}
\maketitle\setcounter{page}{0}\thispagestyle{empty}\clearpage
\clearpage
\tableofcontents\clearpage
\end{titlepage}
\setcounter{section}{-1}
\clearpage\section{头文件}
\begin{lstlisting}
#include <bits/stdc++.h> // c++0x only
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <cmath>
#include <iomanip>
#include <functional>
#include <cstdlib>
#include <climits>
#include <cctype>
using namespace std;
#define clr(a,x) memset(a, x, sizeof(a))
#define mp(x,y) make_pair(x,y)
#define pb(x) push_back(x)
#define X first
#define Y second
#define fastin ios_base::sync_with_stdio(0);cin.tie(0);
typedef long long ll;
typedef long double ld;
typedef pair<int, int> PII;
typedef vector<int> VI;
const int INF = 0x3f3f3f3f;
const int mod = 1e9 + 7;
const double eps = 1e-6;
\end{lstlisting}
\clearpage\section{数学}
\subsection{素数}
\subsubsection{埃氏筛}
\begin{lstlisting}
\end{lstlisting}
$O(n\log\log n)$筛出MAXN内所有素数
$notprime[i] = 0/1$ 0为素数 1为非素数
\begin{lstlisting}
const int MAXN = 1000100;
bool notprime[MAXN] = {1, 1};   // 0 && 1 为非素数
void GetPrime()
{
    for (int i = 2; i < MAXN; i++)
        if (!notprime[i] && i <= MAXN / i)  // 筛到√n为止
            for (int j = i * i; j < MAXN; j += i)
                notprime[j] = 1;
}
\end{lstlisting}
\subsubsection{欧拉筛}
\begin{lstlisting}
\end{lstlisting}
$O(n)$得到欧拉函数$phi[]$、素数表$prime[]$、素数个数$tot$
传入的n为函数定义域上界
\begin{lstlisting}
const int MAXN = 100010;
bool vis[MAXN];
int tot, phi[MAXN], prime[MAXN];
void CalPhi(int n)
{
    clr(vis, 0);
    phi[1] = 1;
    tot = 0;
    for (int i = 2; i < n; i++)
    {
        if (!vis[i])
        {
            prime[tot++] = i;
            phi[i] = i - 1;
        }
        for (int j = 0; j < tot; j++)
        {
            if (i * prime[j] > n) break;
            vis[i * prime[j]] = 1;
            if (i % prime[j] == 0)
            {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            else phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        }
    }
}
\end{lstlisting}
\subsubsection{分解质因数}
\begin{lstlisting}
\end{lstlisting}
函数返回素因数个数
数组以$fact[i][0]^{fact[i][1]}$的形式保存第i个素因数
\begin{lstlisting}
ll fact[100][2];
int getFactors(ll x)
{
    int cnt = 0;
    for (int i = 0; prime[i] <= x / prime[i]; i++)
    {
        fact[cnt][1] = 0;
        if (x % prime[i] == 0 )
        {
            fact[cnt][0] = prime[i];
            while (x % prime[i] == 0)
            {
                fact[cnt][1]++;
                x /= prime[i];
            }
            cnt++;
        }
    }
    if (x != 1)
    {
        fact[cnt][0] = x;
        fact[cnt++][1] = 1;
    }
    return cnt;
}
\end{lstlisting}
\subsubsection{随机素数判定}
\begin{lstlisting}
\end{lstlisting}
$O(s\log n)$内判定$2^{63}$内的数是不是素数，$s$为测定次数
\begin{lstlisting}
bool Miller_Rabin(ll n, int s)
{
    if (n == 2) return 1;
    if (n < 2 || !(n & 1)) return 0;
    int t = 0;
    ll  x, y, u = n - 1;
    while ((u & 1) == 0) t++, u >>= 1;
    for (int i = 0; i < s; i++)
    {
        ll a = rand() % (n - 1) + 1;
        ll x = Pow(a, u, n);
        for (int j = 0; j < t; j++)
        {
            ll y = Mul(x, x, n);
            if (y == 1 && x != 1 && x != n - 1) return 0;
            x = y;
        }
        if (x != 1) return 0;
    }
    return 1;
}
\end{lstlisting}
\subsection{欧拉函数}
\subsubsection{求一个数的欧拉函数}
\begin{lstlisting}
long long Euler(long long n)
{
    long long rt = n;
    for (int i = 2; i * i <= n; i++)
        if (n % i == 0)
        {
            rt -= rt / i;
            while (n % i == 0) n /= i;
        }
    if (n > 1) rt -= rt / n;
    return rt;
}
\end{lstlisting}
\subsubsection{筛法求欧拉函数}
\begin{lstlisting}
const int N = 10001;
int phi[N] = {0, 1};
void CalEuler()
{
    for (int i = 2; i < N; i++)
        if (!phi[i]) for (int j = i; j < N; j += i)
            {
                if (!phi[j]) phi[j] = j;
                phi[j] = phi[j] / i * (i - 1);
            }
}
\end{lstlisting}
\subsection{扩展欧几里得-乘法逆元}
\subsubsection{扩展欧几里得}
\begin{lstlisting}
ll exgcd(ll a, ll b, ll &x, ll &y)
{
    ll d = a;
    if (b)
        d = exgcd(b, a % b, y, x), y -= x * (a / b);
    else
        x = 1, y = 0;
    return d;
}
\end{lstlisting}
\subsubsection{求ax+by=c的解}
\begin{lstlisting}
// 引用返回通解: X = x + k * dx, Y = y – k * dy
// 引用返回的x是最小非负整数解，方程无解函数返回0
#define Mod(a,b) (((a)%(b)+(b))%(b))
bool solve(ll a, ll b, ll c, ll &x, ll &y, ll &dx, ll &dy)
{
    if (a == 0 && b == 0) return 0;
    ll x0, y0;
    ll d = exgcd(a, b, x0, y0);
    if (c % d != 0) return 0;
    dx = b / d;
    dy = a / d;
    x = Mod(x0 * c / d, dx);
    y = (c - a * x) / b;
//  y = Mod(y0 * c / d, dy); x = (c - b * y) / a;
    return 1;
}
\end{lstlisting}
\subsubsection{乘法逆元}
\begin{lstlisting}
// 利用exgcd求a在模m下的逆元，需要保证gcd(a, m) == 1.
ll inv(ll a, ll m)
{
    ll x, y;
    ll d = exgcd(a, m,  x, y);
    return d == 1 ? (x + m) % m : -1;
}
// a < m 且 m为素数时，有以下两种求法
ll inv(ll a, ll m)
{
    return a == 1 ? 1 : inv(m % a, m) * (m - m / a) % m;
}
ll inv(ll a, ll m)
{
    return Pow(a, m – 2, m);
}
\end{lstlisting}
\subsection{模线性方程组}
\subsubsection{中国剩余定理}
\begin{lstlisting}
// X = r[i] (mod m[i]); 要求m[i]两两互质
// 引用返回通解X = re + k * mo;
void crt(ll r[], ll m[], ll n, ll &re, ll &mo)
{
    mo = 1, re = 0;
    for (int i = 0; i < n; i++) mo *= m[i];
    for (int i = 0; i < n; i++)
    {
        ll x, y,  tm = mo / m[i];
        ll d = exgcd(tm, m[i], x, y);
        re = (re + tm * x * r[i]) % mo;
    }
    re = (re + mo) % mo;
}
\end{lstlisting}
\subsubsection{一般模线性方程组}
\begin{lstlisting}
// X = r[i] (mod m[i]); m[i]可以不两两互质
// 引用返回通解X = re + k * mo; 函数返回是否有解
bool excrt(ll r[], ll m[], ll n, ll &re, ll &mo)
{
    ll x, y;
    mo = m[0], re = r[0];
    for (int i = 1; i < n; i++)
    {
        ll d = exgcd(mo, m[i],  x, y);
        if ((r[i] - re) % d != 0) return 0;
        x = (r[i] - re) / d * x % (m[i] / d);
        re += x * mo;
        mo = mo / d * m[i];
        re %= mo;
    }
    re = (re + mo) % mo;
    return 1;
}
\end{lstlisting}
\subsection{组合数学}
\subsubsection{一般组合数}
\begin{lstlisting}
\end{lstlisting}
$0 \leq m \leq n \leq 1000$
\begin{lstlisting}
const int maxn = 1010;
ll C[maxn][maxn];
void CalComb()
{
    C[0][0] = 1;
    for (int i = 1; i < maxn; i++)
    {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    }
}

\end{lstlisting}
$0 \leq m \leq n \leq 10^5$, 模p为素数
\begin{lstlisting}
const int maxn = 100010;
ll f[maxn];
void CalFact()
{
    f[0] = 1;
    for (int i = 1; i < maxn; i++)
        f[i] = (f[i - 1] * i) % mod;
}
ll C(int n, int m)
{
    return f[n] * inv(f[m] * f[n - m] % mod, mod) % mod;
}
\end{lstlisting}
\subsubsection{Lucas定理}
\begin{lstlisting}
// 1 <= n, m <= 1000000000, 1 < p < 100000, p是素数
const int maxp = 100010;
ll f[maxp];
void CalFact(ll p)
{
    f[0] = 1;
    for (int i = 1; i <= p; i++)
        f[i] = (f[i - 1] * i) % p;
}
ll Lucas(ll n, ll m, ll p)
{
    ll ret = 1;
    while (n && m)
    {
        ll a = n % p, b = m % p;
        if (a < b) return 0;
        ret = (ret * f[a] * Pow(f[b] * f[a - b] % p, p - 2, p)) % p;
        n /= p;
        m /= p;
    }
    return ret;
}
\end{lstlisting}
\subsubsection{大组合数}
\begin{lstlisting}
// 0 <= n <= 109, 0 <= m <= 104, 1 <= k <= 109+7
vector<int> v;
int dp[110];
ll Cal(int l, int r, int k, int dis)
{
    ll res = 1;
    for (int i = l; i <= r; i++)
    {
        int t = i;
        for (int j = 0; j < v.size(); j++)
        {
            int y = v[j];
            while (t % y == 0)
            {
                dp[j] += dis;
                t /= y;
            }
        }
        res = res * (ll)t % k;
    }
    return res;
}
ll Comb(int n, int m, int k)
{
    set(dp, 0);
    v.clear();
    int tmp = k;
    for (int i = 2; i * i <= tmp; i++)
    {
        if (tmp % i == 0)
        {
            int num = 0;
            while (tmp % i == 0)
            {
                tmp /= i;
                num++;
            }
            v.pb(i);
        }
    }
    if (tmp != 1) v.pb(tmp);
    ll ans = Cal(n - m + 1, n, k, 1);
    for (int j = 0; j < v.size(); j++)
    {
        ans = ans * Pow(v[j], dp[j], k) % k;
    }
    ans = ans * inv(Cal(2, m, k, -1), k) % k;
    return ans;
}
\end{lstlisting}
\subsubsection{Polya定理}
\begin{lstlisting}
\end{lstlisting}
推论：一共$n$个置换，第$i$个置换的循环节个数为$gcd(i,n)$
$N*N$的正方形格子，$c^{n^2}+2c^{\frac{n^2+3}{4}}+c^{\frac{n^2+1}{2}}+2c^{n\frac{n+1}{2}}+2c^{\frac{n(n+1)}{2}}$
正六面体，$\frac{m^8+17m^4+6m^2}{24}$
正四面体，$\frac{m^4+11m^2}{12}$
\begin{lstlisting}
// 长度为n的项链串用c种颜色染
ll solve(int c, int n)
{
    if (n == 0) return 0;
    ll ans = 0;
    for (int i = 1; i <= n; i++)
        ans += Pow(c, __gcd(i, n));
    if (n & 1)
        ans += n * Pow(c, n + 1 >> 1);
    else
        ans += n / 2 * (1 + c) * Pow(c, n >> 1);
    return ans / n / 2;
}
\end{lstlisting}
\subsection{快速乘-快速幂}
\begin{lstlisting}
ll Mul(ll a, ll b, ll mod)
{
    ll t = 0;
    for (; b; b >>= 1, a = (a << 1) % mod)
        if (b & 1) t = (t + a) % mod;
    return t;
}
ll Pow(ll a, ll n, ll mod)
{
    ll t = 1;
    for (; n; n >>= 1, a = (a * a % mod))
        if (n & 1) t = (t * a % mod);
    return t;
}
\end{lstlisting}
\subsection{莫比乌斯反演}
\subsubsection{莫比乌斯}
\begin{lstlisting}
\end{lstlisting}
$F(n)=\sum_{d|n}f(d)\Rightarrow f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})$
$F(n)=\sum_{n|d}f(d)\Rightarrow f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)$
\begin{lstlisting}
long long ans;
const int MAXN = 1e5 + 1;
int n, x, prime[MAXN], tot, mu[MAXN];
bool check[MAXN];
void calmu()
{
    mu[1] = 1;
    for (int i = 2; i < MAXN; i++)
    {
        if (!check[i])
        {
            prime[tot++] = i;
            mu[i] = -1;
        }
        for (int j = 0; j < tot; j++)
        {
            if (i * prime[j] >= MAXN) break;
            check[i * prime[j]] = true;
            if (i % prime[j] == 0)
            {
                mu[i * prime[j]] = 0;
                break;
            }
            else
            {
                mu[i * prime[j]] = -mu[i];
            }
        }
    }
}
\end{lstlisting}
\subsubsection{n个数中互质数对数}
\begin{lstlisting}
//  有n个数（n<=100000），问这n个数中互质的数的对数
clr(b, 0);
_max = 0;
ans = 0;
for (int i = 0; i < n; i++)
{
    scanf("%d", &x);
    if (x > _max) _max = x;
    b[x]++;
}
int cnt;
for (int i = 1; i <= _max; i++)
{
    cnt = 0;
    for (long long j = i; j <= _max; j += i)
        cnt += b[j];
    ans += 1LL * mu[i] * cnt * cnt;
}
printf("%lld\n", (ans - b[1]) / 2);
\end{lstlisting}
\subsubsection{VisibleTrees}
\begin{lstlisting}
// gcd(x,y)==1的对数 x<=n, y<=m
int main()
{
    calmu();
    int n, m;
    scanf("%d %d", &n, &m);
    if (n < m) swap(n, m);
    ll ans = 0;
    for (int i = 1; i <= m; ++i)
    {
        ans += (ll)mu[i] * (n / i) * (m / i);
    }
    printf("%lld\n", ans);
    return 0;
}
\end{lstlisting}
\subsection{其他}
\subsubsection{Josephus问题}
\begin{lstlisting}
int num, m, r
while (cin >> num >> m)
{
    r = 0;
    for (int k = 1; k <= num; ++k)
        r = (r + m) % k;
    cout << r + 1 << endl;
}
\end{lstlisting}
\subsubsection{数位问题}
\begin{lstlisting}
// n^n最左边一位数
int leftmost(int n)
{
    double m = n * log10((double)n);
    double g = m - (long long)m;
    g = pow(10.0, g);
    return (int)g;
}

// n!位数
int count(ll n)
{
    return n == 1 ? 1 : (int)ceil(0.5 * log10(2 * M_PI * n) + n * log10(n) - n * log10(M_E));
}
\end{lstlisting}
\subsubsection{FFT}
\begin{lstlisting}
const double PI = acos(-1.0);
//复数结构体
struct Complex
{
    double x, y; //实部和虚部 x+yi
    Complex(double _x = 0.0, double _y = 0.0)
    {
        x = _x;
        y = _y;
    }
    Complex operator-(const Complex &b) const
    {
        return Complex(x - b.x, y - b.y);
    }
    Complex operator+(const Complex &b) const
    {
        return Complex(x + b.x, y + b.y);
    }
    Complex operator*(const Complex &b) const
    {
        return Complex(x * b.x - y * b.y, x * b.y + y * b.x);
    }
};
/*
* 进行FFT和IFFT前的反转变换。
* 位置i和 （i二进制反转后位置）互换
* len必须取2的幂
*/
void change(Complex y[], int len)
{
    int i, j, k;
    for (i = 1, j = len / 2; i < len - 1; i++)
    {
        if (i < j)
            swap(y[i], y[j]);
        //交换互为小标反转的元素，i<j保证交换一次
        //i做正常的+1，j左反转类型的+1,始终保持i和j是反转的
        k = len / 2;
        while (j >= k)
        {
            j -= k;
            k /= 2;
        }
        if (j < k)
            j += k;
    }
}
/*
* 做FFT
* len必须为2^k形式，
* on==1时是DFT，on==-1时是IDFT
*/
void fft(Complex y[], int len, int on)
{
    change(y, len);
    for (int h = 2; h <= len; h <<= 1)
    {
        Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h));
        for (int j = 0; j < len; j += h)
        {
            Complex w(1, 0);
            for (int k = j; k < j + h / 2; k++)
            {
                Complex u = y[k];
                Complex t = w * y[k + h / 2];
                y[k] = u + t;
                y[k + h / 2] = u - t;
                w = w * wn;
            }
        }
    }
    if (on == -1)
        for (int i = 0; i < len; i++)
            y[i].x /= len;
}
\end{lstlisting}
\subsection{相关公式}
\begin{enumerate}
\item 约数定理：若$n=\prod_{i=1}^kp_i^{a_i}$，则

\begin{enumerate}
\item 约数个数$f(n)=\prod_{i=1}^k(a_i+1)$
\item 约数和$g(n)=\prod_{i=1}^k(\sum_{j=0}^{a_i}p_i^j)$
\end{enumerate}

\item 小于$n$且互素的数之和为$n\varphi(n)/2$

\item 若$gcd(n,i)=1$，则$gcd(n,n-i)=1(1\leq i\leq n)$

\item 错排公式：$D(n)=(n-1)(D(n-2)+D(n-1))=\sum_{i=2}^n\frac{(-1)^kn!}{k!}=[\frac{n!}{e}+0.5]$

\item 威尔逊定理：$p\ is\ prime\ \Rightarrow (p-1)!\equiv-1(mod\ p)$

\item 欧拉定理：$gcd(a,n)=1\Rightarrow a^{\varphi(n)}\equiv1(mod\ n)$

\item 欧拉定理推广：$gcd(n,p)=1\Rightarrow a^n\equiv a^{n\%\varphi(p)}(mod\ p)$

\item 素数定理：对于不大于n的素数个数$\pi(n)$，$\lim\limits_{n\to\infty}\pi(n)=\frac{n}{\ln n}$

\item 位数公式：正整数$x$的位数$N=log10(n)+1$

\item 斯特灵公式$n!\approx\sqrt{2\pi n}(\frac{n}{e})^n$

\item 设$a>1,m,n>0$,则$gcd(a^m-1,a^n-1)=a^{gcd(m,n)}-1$

\item 设$a>b,gcd(a,b)=1$,则$gcd(a^m-b^m,a^n-b^n)=a^{gcd(m,n)}-b^{gcd(m,n)}$

$$
G=gcd(C_n^1,C_n^2,...,C_n^{n-1})=
\begin{cases}
	n, & \text{$n$ is prime} \\
	1, & \text{$n$ has multy prime factors} \\
	p, & \text{$n$ has single prime factor $p$} 
\end{cases}
$$

$gcd(Fib(m),Fib(n))=Fib(gcd(m,n))$

\item 若$gcd(m,n)=1$,则:

\begin{enumerate}
\item 最大不能组合的数为$m*n-m-n$
\item 不能组合数个数$N=\frac{(m-1)(n-1)}{2}$
\end{enumerate}

\item $(n+1)lcm(C_n^0,C_n^1,...,C_n^{n-1},C_n^{n})=lcm(1,2,...,n+1)$

\item 若$p$为素数，则$(x+y+...+w)^p\equiv x^p+y^p+...+w^p(mod\ p)$

\item 卡特兰数：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012

$h(0)=h(1)=1,h(n)=\frac{(4n-2)h(n-1)}{n+1}=\frac{C_{2n}^n}{n+1}=C_{2n}^n-C_{2n}^{n-1}$

$$
a_{n+m}=\sum_{i=0}^{m-1}b_ia_{n+i}\Rightarrow
\left(
\begin{matrix}
 a_{n+m}    \\\\
 a_{n+m-1}  \\\\
 \vdots     \\\\
 a_{n+1}    \\\\
\end{matrix}
\right)
=
\left(
\begin{matrix}
 b_{m-1} && \cdots && b_1    && b_0    \\\\
 1       && \cdots && 0      && 0      \\\\
 \vdots  && \ddots && \vdots && \vdots \\\\
 0       && \cdots && 1      && 0      \\\\
\end{matrix}
\right)
\left(
\begin{matrix}
 a_{n+m-1} \\\\
 a_{n+m-2} \\\\
 \vdots    \\\\
 a_n       \\\\
\end{matrix}
\right)
$$

$$
a_{n+m}=\sum_{i=0}^{m-1}b_ia_{n+i}+c\Rightarrow
\left(
\begin{matrix}
 a_{n+m}    \\\\
 a_{n+m-1}  \\\\
 \vdots     \\\\
 a_{n+1}    \\\\
 1          \\\\
\end{matrix}
\right)
=
\left(
\begin{matrix}
 b_{m-1} && \cdots && b_1    && b_0    && c      \\\\
 1       && \cdots && 0      && 0      && 0      \\\\
 \vdots  && \ddots && \vdots && \vdots && \vdots \\\\
 0       && \cdots && 1      && 0      && 0      \\\\
 0       && \cdots && 0      && 0      && 1      \\\\
\end{matrix}
\right)
\left(
\begin{matrix}
 a_{n+m-1} \\\\
 a_{n+m-2} \\\\
 \vdots    \\\\
 a_n       \\\\
 1         \\\\
\end{matrix}
\right)
$$
\end{enumerate}
\clearpage\section{动态规划}
\subsection{子序列}
\subsubsection{最大子序列和}
\begin{lstlisting}
// 传入序列a和长度n，返回最大子序列和
// 限制最短长度：用cnt记录长度，rt更新时判断
int MaxSeqSum(int a[], int n)
{
    int rt = 0, cur = 0;
    for (int i = 0; i < n; i++)
    {
        cur += a[i];
        rt = rt < cur ? cur : rt;
        cur = cur < 0 ? 0 : cur;
    }
    return rt;
}
\end{lstlisting}
\subsubsection{最长上升子序列LIS}
\begin{lstlisting}
// 序列下标从1开始，LIS()返回长度，序列存在lis[]中
#define N 100100
int n, len, a[N], b[N], f[N];
int Find(int p, int l, int r)
{
    int mid;
    while (l <= r)
    {
        mid = (l + r) >> 1;
        if (a[p] > b[mid]) l = mid + 1;
        else r = mid - 1;
    }
    return f[p] = l;
}
int LIS(int lis[])
{
    int len = 1;
    f[1] = 1;
    b[1] = a[1];
    for (int i = 2; i <= n; i++)
    {
        if (a[i] > b[len]) b[++len] = a[i], f[i] = len;
        else b[Find(i, 1, len)] = a[i];
    }
    for (int i = n, t = len; i >= 1 && t >= 1; i--)
        if (f[i] == t)
            lis[--t] = a[i];
    return len;
}
\end{lstlisting}
\subsubsection{最长公共上升子序列LCIS}
\begin{lstlisting}
// 序列下标从1开始
int LCIS(int a[], int b[], int n, int m)
{
    set(dp, 0);
    for (int i = 1; i <= n; i++)
    {
        int ma = 0;
        for (int j = 1; j <= m; j++)
        {
            dp[i][j] = dp[i - 1][j];
            if (a[i] > b[j]) ma = max(ma, dp[i - 1][j]);
            if (a[i] == b[j]) dp[i][j] = ma + 1;
        }
    }
    return *max_element(dp[n] + 1, dp[n] + 1 + m);
}
\end{lstlisting}
\clearpage\section{数据结构}
\subsection{树状数组}
\begin{lstlisting}
\end{lstlisting}
$O(\log n)$查询和修改数组的前缀和
\begin{lstlisting}
// 注意下标应从1开始 n是全局变量
int bit[N], n;
int sum(int i)
{
    int s = 0;
    while (i)
    {
        s += bit[i];
        i -= i & -i;
    }
    return s;
}
void add(int i, int x)
{
    while (i <= n)
    {
        bit[i] += x;
        i += i & -i;
    }
}
\end{lstlisting}
\subsection{线段树}
\subsubsection{声明}
\begin{lstlisting}
#define lson rt<<1      // 左儿子
#define rson rt<<1|1    // 右儿子
#define Lson l,m,lson   // 左子树
#define Rson m+1,r,rson // 右子树
void PushUp(int rt);    // 用lson和rson更新rt
void PushDown(int rt[, int m]);
// rt的标记下移，m为区间长度（若与标记有关）
void build(int l, int r, int rt);
// 以rt为根节点，对区间[l, r]建立线段树
void update([...,] int l, int r, int rt)
// rt[l, r]内寻找目标并更新
int query(int L, int R, int l, int r, int rt)
// rt-[l, r]内查询[L, R] 
\end{lstlisting}
\subsubsection{单点更新-区间查询}
\begin{lstlisting}
const int maxn = 50010;
int sum[maxn << 2];
void PushUp(int rt)
{
    sum[rt] = sum[lson] + sum[rson];
}
void build(int l, int r, int rt)
{
    if (l == r)
    {
        scanf("%d", &sum[rt]);
        return;
    }    // 建立的时候直接输入叶节点
    int m = (l + r) >> 1;
    build(Lson);
    build(Rson);
    PushUp(rt);
}
void update(int p, int add, int l, int r, int rt)
{
    if (l == r)
    {
        sum[rt] += add;
        return;
    }
    int m = (l + r) >> 1;
    if (p <= m) update(p, add, Lson);
    else update(p, add, Rson);
    PushUp(rt);
}
int query(int L, int R, int l, int r, int rt)
{
    if (L <= l && r <= R) return sum[rt];
    int m = (l + r) >> 1, s = 0;
    if (L <= m) s += query(L, R, Lson);
    if (m < R) s += query(L, R, Rson);
    return s;
}
\end{lstlisting}
\subsubsection{区间更新-区间查询}
\begin{lstlisting}
// seg[rt]用于存放懒惰标记，注意PushDown时标记的传递
const int maxn = 101010;
int seg[maxn << 2], sum[maxn << 2];

void PushUp(int rt)
{
    sum[rt] = sum[lson] + sum[rson];
}
void PushDown(int rt, int m)
{
    if (seg[rt] == 0) return;
    seg[lson] += seg[rt];
    seg[rson] += seg[rt];
    sum[lson] += seg[rt] * (m - (m >> 1));
    sum[rson] += seg[rt] * (m >> 1);
    seg[rt] = 0;
}
void build(int l, int r, int rt)
{
    seg[rt] = 0;
    if (l == r)
    {
        scanf("%lld", &sum[rt]);
        return;
    }
    int m = (l + r) >> 1;
    build(Lson);
    build(Rson);
    PushUp(rt);
}
void update(int L, int R, int add, int l, int r, int rt)
{
    if (L <= l && r <= R)
    {
        seg[rt] += add;
        sum[rt] += add * (r - l + 1);
        return;
    }
    PushDown(rt, r - l + 1);
    int m = (l + r) >> 1;
    if (L <= m) update(L, R, add, Lson);
    if (m < R) update(L, R, add, Rson);
    PushUp(rt);
}
int query(int L, int R, int l, int r, int rt)
{
    if (L <= l && r <= R) return sum[rt];
    PushDown(rt, r - l + 1);
    int m = (l + r) >> 1, ret = 0;
    if (L <= m) ret += query(L, R, Lson);
    if (m < R) ret += query(L, R, Rson);
    return ret;
}
\end{lstlisting}
\subsection{RMQ}
\begin{lstlisting}
const int MAXN = 200000 + 100;
int mmax[MAXN][30], mmin[MAXN][30];
int a[MAXN], n, k;
void init()
{
    for (int i = 1; i <= n; i++)
    {
        mmax[i][0] = mmin[i][0] = a[i];
    }
    for (int j = 1; (1 << j) <= n; j++)
        for (int i = 1; i + (1 << j) - 1 <= n; i++)
        {
            mmax[i][j] =
                max(mmax[i][j - 1], mmax[i + (1 << (j - 1))][j - 1]);
            mmin[i][j] =
                min(mmin[i][j - 1], mmin[i + (1 << (j - 1))][j - 1]);
        }
}
// op=0/1 返回[l,r]最大/小值
int rmq(int l, int r, int op)
{
    int k = 0;
    while ((1 << (k + 1)) <= r - l + 1) k++;
    if (op == 0)
        return max(mmax[l][k], mmax[r - (1 << k) + 1][k]);
    return min(mmin[l][k], mmin[r - (1 << k) + 1][k]);
}

// 二维情况
void init()
{
    for (int i = 0; (1 << i) <= n; i++)
        for (int j = 0; (1 << j) <= m; j++)
        {
            if (i == 0 && j == 0) continue;
            for (int row = 1; row + (1 << i) - 1 <= n; row++)
                for (int col = 1; col + (1 << j) - 1 <= m; col++)
                    //当x或y等于0的时候，就相当于一维的RMQ了
                    if (i == 0)
                        dp[row][col][i][j] =
                            max(dp[row][col][i][j - 1],
                                dp[row][col + (1 << (j - 1))][i][j - 1]);
                    else if (j == 0)
                        dp[row][col][i][j] =
                            max(dp[row][col][i - 1][j],
                                dp[row + (1 << (i - 1))][col][i - 1][j]);
                    else dp[row][col][i][j] =
                            max(dp[row][col][i][j - 1],
                                dp[row][col + (1 << (j - 1))][i][j - 1]);
        }
}
int rmq(int x1, int y1, int x2, int y2)
{
    int kx = 0, ky = 0;
    while (x1 + (1 << (1 + kx)) - 1 <= x2) kx++;
    while (y1 + (1 << (1 + ky)) - 1 <= y2) ky++;
    int m1 = dp[x1][y1][kx][ky];
    int m2 = dp[x2 - (1 << kx) + 1][y1][kx][ky];
    int m3 = dp[x1][y2 - (1 << ky) + 1][kx][ky];
    int m4 = dp[x2 - (1 << kx) + 1][y2 - (1 << ky) + 1][kx][ky];
    return max(max(m1, m2), max(m3, m4));
}
\end{lstlisting}
\clearpage\section{图论}
\subsection{并查集}
\begin{lstlisting}
const int MAXN = 128;
int n, fa[MAXN], ra[MAXN];
void init()
{
    for (int i = 0; i <= n; i++)
    {
        fa[i] = i;
        ra[i] = 0;
    }
}
int find(int x)
{
    if (fa[x] != x) fa[x] = find(fa[x]);
    return fa[x];
}
void unite(int x, int y)
{
    x = find(x);
    y = find(y);
    if (x == y) return;
    if (ra[x] < ra[y]) fa[x] = y;
    else
    {
        fa[y] = x;
        if (ra[x] == ra[y]) ra[x]++;
    }
}
bool same(int x, int y)
{
    return find(x) == find(y);
}
\end{lstlisting}
\subsection{最小生成树}
\subsubsection{Kruskal}
\begin{lstlisting}
vector<pair<int, PII> > G;
void add_edge(int u, int v, int d)
{
    G.pb(mp(d, mp(u, v)));
}
int Kruskal(int n)
{
    init(n);
    sort(G.begin(), G.end());
    int m = G.size();
    int num = 0, ret = 0;
    for (int i = 0; i < m; i++)
    {
        pair<int, PII> p = G[i];
        int x = p.Y.X;
        int y = p.Y.Y;
        int d = p.X;
        if (!same(x, y))
        {
            unite(x, y);
            num++;
            ret += d;
        }
        if (num == n - 1) break;
    }
    return ret;
}
\end{lstlisting}
\subsubsection{Prim}
\begin{lstlisting}
// 耗费矩阵cost[][],标号从0开始,0~n-1
// 返回最小生成树的权值,返回-1表示原图不连通
const int INF = 0x3f3f3f3f;
const int MAXN = 110;
bool vis[MAXN];
int lowc[MAXN];
int Prim(int cost[][MAXN], int n)
{
    int ans = 0;
    clr(vis, 0);
    vis[0] = 1;
    for (int i = 1; i < n; i++)
        lowc[i] = cost[0][i];
    for (int i = 1; i < n; i++)
    {
        int minc = INF;
        int p = -1;
        for (int j = 0; j < n; j++)
            if (!vis[j] && minc > lowc[j])
            {
                minc = lowc[j];
                p = j;
            }
        if (minc == INF) return -1;
        vis[p] = 1;
        ans += minc;
        for (int j = 0; j < n; j++)
            if (!vis[j] && lowc[j] > cost[p][j])
                lowc[j] = cost[p][j];
    }
    return ans;
}
\end{lstlisting}
\subsection{最短路}
\subsubsection{Dijkstra-邻接矩阵}
\begin{lstlisting}
// N为点数最大值 求s到所有点的最短路
// 要求边权值为非负数 模板为有向边
// dis[x]为起点到点x的最短路 inf表示无法走到
// 记得初始化
const int N = 100;  // 点数最大值
const int INF = 0x3f3f3f3f;
int G[N][N], dis[N];
bool vis[N];
void init(int n)
{
    clr(G, 0x3f);
}
void add_edge(int u, int v, int w)
{
    G[u][v] = min(G[u][v], w);
}
void Dijkstra(int s, int n)
{
    clr(vis, 0);
    clr(dis, 0x3f);
    dis[s] = 0;
    for (int i = 0; i < n; i++)
    {
        int x, minDis = INF;
        for (int j = 0; j < n; j++)
        {
            if (!vis[j] && dis[j] <= minDis)
            {
                x = j;
                minDis = dis[j];
            }
        }
        vis[x] = 1;
        for (int j = 0; j < n; j++)
            dis[j] = min(dis[j], dis[x] + G[x][j]);
    }
}
\end{lstlisting}
\subsubsection{Dijkstra-优先队列}
\begin{lstlisting}
// pair<权值, 点>
// 记得初始化
const int maxn = "Edit";
const int INF = 0x3f3f3f3f;
typedef pair<int, int> PII;
typedef vector<PII> VII;
VII G[maxn];
int vis[maxn], dis[maxn];
void init(int n)
{
    for (int i = 0; i < n; i++)
        G[i].clear();
}
void add_edge(int u, int v, int w)
{
    G[u].pb(mp(w, v));
}
void Dijkstra(int s, int n)
{
    clr(vis, 0);
    clr(dis, 0x3f);
    dis[s] = 0;
    priority_queue<PII, VII, greater<PII> > q;
    q.push(mp(dis[s], s));
    while (!q.empty())
    {
        PII t = q.top();
        int x = t.Y;
        q.pop();
        if (vis[x]) continue;
        vis[x] = 1;
        for (int i = 0; i < G[x].size(); i++)
        {
            int y = G[x][i].Y;
            int w = G[x][i].X;
            if (!vis[y] && dis[y] > dis[x] + w)
            {
                dis[y] = dis[x] + w;
                q.push(mp(dis[y], y));
            }
        }
    }
}
\end{lstlisting}
\subsubsection{Bellman-Ford(可判负环)}
\begin{lstlisting}
// 求出起点s到每个点x的最短路dis[x]
// 存在负环返回1 否则返回0
// 记得初始化
const int MAX_N = "Edit";   // 点数最大值
const int MAX_E = "Edit";   // 边数最大值
const int INF = 0x3f3f3f3f;
int From[MAX_E], To[MAX_E], W[MAX_E];
int dis[MAX_N], tot;
void init()
{
    tot = 0;
}
void add_edge(int u, int v, int d)
{
    From[tot] = u;
    To[tot] = v;
    W[tot++] = d;
}
bool Bellman_Ford(int s, int n)
{
    clr(dis, 0x3f);
    dis[s] = 0;
    for (int k = 0; k < n - 1; k++)
    {
        bool relaxed = 0;
        for (int i = 0; i < tot; i++)
        {
            int x = From[i], y = To[i];
            if (dis[y] > dis[x] + W[i])
            {
                dis[y] = dis[x] + W[i];
                relaxed = 1;
            }
        }
        if (!relaxed) break;
    }
    for (int i = 0; i < tot; i++)
        if (dis[To[i]] > dis[From[i]] + W[i])
            return 1;
    return 0;
}
\end{lstlisting}
\subsubsection{SPFA}
\begin{lstlisting}
// G[u] = mp(v, w)
// SPFA()返回0表示存在负环
const int MAXN = "Edit";
const int INF = 0x3f3f3f3f;
vector<pair<int, int> > G[MAXN];
bool vis[MAXN];
int dis[MAXN];
int inqueue[MAXN];
void init(int n)
{
    for (int i = 0; i < n; i++)
        G[i].clear();
}
void add_edge(int u, int v, int w)
{
    G[u].pb(mp(v, w));
}
bool SPFA(int s, int n)
{
    clr(vis, 0);
    clr(dis, 0x3f);
    clr(inqueue, 0);
    dis[s] = 0;
    queue<int> q;   // 待优化的节点入队
    q.push(s);
    while (!q.empty())
    {
        int x = q.front();
        q.pop();
        vis[x] = false;
        for (int i = 0; i < G[x].size(); i++)
        {
            int y = G[x][i].X;
            int w = G[x][i].Y;
            if (dis[y] > dis[x] + w)
            {
                dis[y] = dis[x] + w;
                if (!vis[y])
                {
                    q.push(y);
                    vis[y] = true;
                    if (++inqueue[y] >= n) return 0;
                }
            }
        }
    }
    return 1;
}
\end{lstlisting}
\subsubsection{Floyd算法}
\begin{lstlisting}
\end{lstlisting}
$O(n^3)$求出任意两点间最短路
\begin{lstlisting}
const int MAXN = "Edit";
const int INF = 0x3f3f3f3f;
int G[MAXN][MAXN];
void init(int n)
{
    clr(G, 0x3f);
    for (int i = 0; i < n; i++)
        G[i][i] = 0;
}
void add_edge(int u, int v, int w)
{
    G[u][v] = min(G[u][v], w);
}
void Floyd(int n)
{
    for (int k = 0; k < n; k++)
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                G[i][j] = min(G[i][j], G[i][k] + G[k][j]);
}
\end{lstlisting}
\subsection{拓扑排序}
\subsubsection{邻接矩阵}
\begin{lstlisting}
// 存图前记得初始化
// Ans存放拓排结果，G为邻接矩阵，deg为入度信息
// 排序成功返回1，存在环返回0
const int maxn = "Edit";
int Ans[maxn];      // 存放拓扑排序结果
int G[maxn][maxn];  // 存放图信息
int deg[maxn];      // 存放点入度信息
void init()
{
    clr(G, 0);
    clr(deg, 0);
    clr(Ans, 0);
}
void add_edge(int u, int v)
{
    if (G[u][v]) return;
    G[u][v] = 1;
    deg[v]++;
}
bool Toposort(int n)
{
    int tot = 0;
    queue<int> que;
    for (int i = 0; i < n; ++i)
        if (deg[i] == 0) que.push(i);
    while (!que.empty())
    {
        int v = que.front();
        que.pop();
        Ans[tot++] = v;
        for (int i = 0; i < n; ++i)
            if (G[v][i] == 1)
                if (--deg[i] == 0) que.push(i);
    }
    if (tot < n) return false;
    return true;
}
\end{lstlisting}
\subsubsection{邻接表}
\begin{lstlisting}
// 存图前记得初始化
// Ans排序结果，G邻接表，deg入度，map用于判断重边
// 排序成功返回1，存在环返回0
const int maxn = "Edit";
typedef pair<int, int> PII;
int Ans[maxn];
vector<int> G[maxn];
int deg[maxn];
map<PII, bool> S;
void init(int n)
{
    S.clear();
    for (int i = 0; i < n; i++)G[i].clear();
    clr(deg, 0);
    clr(Ans, 0);
}
void add_edge(int u, int v)
{
    if (S[mp(u, v)]) return;
    G[u].pb(v);
    S[mp(u, v)] = 1;
    deg[v]++;
}
bool Toposort(int n)
{
    int tot = 0;
    queue<int> que;
    for (int i = 0; i < n; ++i)
        if (deg[i] == 0) que.push(i);
    while (!que.empty())
    {
        int v = que.front();
        que.pop();
        Ans[tot++] = v;
        for (int i = 0; i < G[v].size(); ++i)
        {
            int t = G[v][i];
            if (--deg[t] == 0) que.push(t);
        }
    }
    if (tot < n) return false;
    return true;
}
\end{lstlisting}
\subsection{欧拉回路}
\subsubsection{判定}
\begin{lstlisting}
\end{lstlisting}
\newtheorem{theorem}{定理}
\begin{theorem}
无向图G存在欧拉通路的充要条件是：G为连通图，并且G仅有两个奇度结点或无奇度结点。
\end{theorem}
\newtheorem{corollary}{推论}
\begin{corollary}

(1) 当G是仅有两个奇度结点的连通图时，G的欧拉通路必以此两个结点为端点。
(2) 当G时无奇度结点的连通图时，G必有欧拉回路。
(3) G为欧拉图（存在欧拉回路）的充要条件是G为无奇度结点的连通图。
\end{corollary}
\begin{theorem}
有向图D存在欧拉通路的充要条件是：D为有向图，D的基图连通，并且所有顶点的出度与入度都相等；或者除两个顶点外，其余顶点的出度与入度都相等，而这两个顶点中一个顶点的出度与入度只差为1，另一个顶点的出度与入度之差为-1。
\end{theorem}
\begin{corollary}

(1) 当D除出、入度之差为1，-1的两个顶点之外，其余顶点的出度与入度都相等时，D的有向欧拉通路必以出、入度之差为1的顶点作为始点，以出、入度之差为-1的顶点作为终点。
(2) 当D的所有顶点的出、入度都相等时，D中存在有向欧拉回路。
(3) 有向图D为有向欧拉图的充要条件是D的基图为连通图，并且所有顶点的出、入度都相等。
\end{corollary}
\begin{lstlisting}
\end{lstlisting}
\subsubsection{求解}
\begin{lstlisting}
struct stack
{
    int top, node[MAXN];
} s;
int G[MAXN][MAXN];  // 邻接矩阵
int n;  // 顶点个数
void dfs(int x)
{
    int i;
    s.node[++s.top] = x;
    for (int i = 0; i < n; i++)
        if (G[i][x] > 0)
        {
            G[i][x] = G[x][i] = 0;
            dfs(i);
            break;
        }
}
void Fleury(int x)
{
    int i, b;
    s.node[s.top = 0] = x;
    while (s.top >= 0)
    {
        b = 0;
        for (int i = 0; i < n; i++)
            if (G[s.node[s.top]][i] > 0)
            {
                b = 1;
                break;
            }
        if (b == 0)
        {
            printf("%d ", s.node[s.top] + 1);
            s.top--;
        }
        else
        {
            s.top--;
            dfs(s.node[s.top + 1]);
        }
    }
    printf("\n");
}
int main()
{
    int i, j;
    int m, s, t; // 边数，读入的边的起点和终点
    int degree, num, start; // 每个顶点的度、奇度顶点个数、欧拉回路的起点
    scanf("%d%d", &n, &m);
    clr(G, 0);
    for (i = 0; i < m; i++)
    {
        scanf("%d%d", &s, &t)
        G[s - 1][t - 1] = G[t - 1][s - 1] = 1;
    }
    num = 0;
    start = 0;
    for (i = 0; i < n; i++)
    {
        degree = 0;
        for (j = 0; j < n; j++)
            degree += G[i][j];
        if (degree & 1)
        {
            start = i;
            num++;
        }
    }
    if (num == 0 || num == 2) Fleury(start);
    else puts("No Euler path");
    return 0;
}
\end{lstlisting}
\subsection{无向图的双连通分量}
\begin{lstlisting}
//割顶的bccno无意义
int pre[maxn], iscut[maxn], bccno[maxn], dfs_clock, bcc_cnt;
vector<int> G[maxn], bcc[maxn];
stack<PII> s;
void init(int n)
{
    for (int i = 0; i < n; i++)
        G[i].clear();
}
void add_edge(int u, int v)
{
    G[u].pb(v);
    G[v].pb(u);
}
int dfs(int u, int fa)
{
    int lowu = pre[u] = ++dfs_clock;
    int child = 0;
    for (int i = 0; i < G[u].size(); i++)
    {
        int v = G[u][i];
        PII e = mp(u, v);
        if (!pre[v])
        {
            //没有访问过v
            s.push(e);
            child++;
            int lowv = dfs(v, u);
            lowu = min(lowu, lowv);     //用后代的low函数更新自己
            if (lowv >= pre[u])
            {
                iscut[u] = true;
                bcc_cnt++;
                bcc[bcc_cnt].clear();   //注意！bcc从1开始编号
                for (;;)
                {
                    PII x = s.top();
                    s.pop();
                    if (bccno[x.X] != bcc_cnt)
                    {
                        bcc[bcc_cnt].pb(x.X);
                        bcc[x.X] = bcc_cnt;
                    }
                    if (bccno[x.Y] != bcc_cnt)
                    {
                        bcc[bcc_cnt].pb(x.Y);
                        bcc[x.Y] = bcc_cnt;
                    }
                    if (x.X == u && x.Y == v) break;
                }
            }
        }
        else if (pre[v] < pre[u] && v != fa)
        {
            s.push(e);
            lowu = min(lowu, pre[v]);   //用反向边更新自己
        }
    }
    if (fa < 0 && child == 1) iscut[u] = 0;
    return lowu;
}
void find_bcc(int n)
{
    //调用结束后s保证为空，所以不用清空
    clr(pre, 0);
    clr(iscut, 0);
    clr(bccno, 0);
    dfs_clock = bcc_cnt = 0;
    for (int i = 0; i < n; i++)
        if (!pre[i]) dfs(i, -1);
}
\end{lstlisting}
\subsection{有向图的强联通分量}
\begin{lstlisting}
vector <int> G[maxn];
int pre[maxn], lowlink[maxn], sccno[maxn], dfs_clock, scc_cnt;
stack<int> S;
void add_edge(int u, int v)
{
    G[u].pb(v);
}
void dfs(int u)
{
    pre[u] = lowlink[u] = ++dfs_clock;
    S.push(u);
    for (int i = 0; i < G[u].size(); i++)
    {
        int v = G[u][i];
        if (!pre[v])
        {
            dfs(v);
            lowlink[u] = min(lowlink[u], lowlink[v]);
        }
        else if (!sccno[v])
            lowlink[u] = min(lowlink[u], pre[v]);
    }
    if (lowlink[u] == pre[u])
    {
        scc_cnt++;
        for (;;)
        {
            int x = S.top();
            S.pop();
            sccno[x] = scc_cnt;
            if (x == u) break;
        }
    }
}
void find_scc(int n)
{
    dfs_clock = 0, scc_cnt = 0;
    clr(sccno, 0);
    clr(pre, 0);
    for (int i = 0; i < n; i++)
        if (!pre[i]) dfs(i);
}
\end{lstlisting}
\subsection{二分图匹配}
1)一个二分图中的最大匹配数等于这个图中的最小点覆盖数

König 定理是一个二分图中很重要的定理,它的意思是,一个二分图中的最大匹配数等于这个图中的最小点覆盖数。如果你还不知道什么是最小点覆盖,我也在这里说一下:假如选了一个点就相当于覆盖了以它为端点的所有边,你需要选择最少的点来覆盖所有的边。

2)最小路径覆盖=|G|-最大匹配数

在一个 N*N 的有向图中,路径覆盖就是在图中找一些路经,使之覆盖了图中的所有顶点,且任何一个顶点有且只有一条路径与之关联;

(如果把这些路径中的每条路径从它的起始点走到它的终点,那么恰好可以经过图中的每个顶点一次且仅一次);如果不考虑图中存在回路,那么每每条路径就是一个弱连通子集.

由上面可以得出:

1.一个单独的顶点是一条路径;

2.如果存在一路径 $p_1,p_2,......p_k$,其中 $p_1$ 为起点,$p_k$ 为终点,那么在覆盖图中,顶点 $p_1,p2,......p_k$ 不再与其它的顶点之间存在有向边.

最小路径覆盖就是找出最小的路径条数,使之成为 G 的一个路径覆盖.

路径覆盖与二分图匹配的关系:最小路径覆盖=|G|-最大匹配数;

3)二分图最大独立集=顶点数-二分图最大匹配

独立集:图中任意两个顶点都不相连的顶点集合。
\subsubsection{匈牙利算法(领接矩阵)}
\begin{lstlisting}
/*
二分图匹配(匈牙利算法的DFS实现)(邻接矩阵形式)
初始化:g[][]两边顶点的划分情况
建立g[i][j]表示i->j的有向边就可以了,是左边向右边的匹配
g没有边相连则初始化为0
uN是匹配左边的顶点数,vN是匹配右边的顶点数
调用:res=hungary();输出最大匹配数
优点:适用于稠密图,DFS找增广路,实现简洁易于理解
时间复杂度:O(VE)
顶点编号从0开始的
*/
const int maxn = "Edit";
int uN, vN; //u,v的数目,使用前面必须赋值
int g[maxn][maxn];//邻接矩阵
int linker[maxn];
bool used[maxn];
bool dfs(int u)
{
    for (int v = 0; v < vN; v++)
        if (g[u][v] && !used[v])
        {
            used[v] = true;
            if (linker[v] == -1 || dfs(linker[v]))
            {
                linker[v] = u;
                return true;
            }
        }
    return false;
}
int hungary()
{
    int res = 0;
    clr(linker, -1);
    for (int u = 0; u < uN; u++)
    {
        clr(used, 0);
        if (dfs(u))res++;
    }
    return res;
}
\end{lstlisting}
\subsubsection{匈牙利算法(领接表)}
\begin{lstlisting}
/*
匈牙利算法邻接表形式
使用前用init()进行初始化
加边使用函数addedge(u,v)
*/

const int maxn = "Edit";
int n;
vector<int> G[maxn];
int linker[maxn];
bool used[maxn];
void init(int n)
{
    for (int i = 0; i < n; i++)
        G[i].clear();
}
void addedge(int u, int v)
{
    G[u].pb(v);
}
bool dfs(int u)
{
    for (int i = 0; i < G[u].size(); i++)
    {
        int v = G[u][i];
        if (!used[v])
        {
            used[v] = true;
            if (linker[v] == -1 || dfs(linker[v]))
            {
                linker[v] = u;
                return true;
            }
        }
    }
    return false;
}
int hungary()
{
    int ans = 0;
    clr(linker, -1);
    for (int u = 0; u < n; v++)
    {
        clr(vis, 0);
        if (dfs(u)) ans++;
    }
    return ans;
}
\end{lstlisting}
\subsection{2-SAT}
\begin{lstlisting}
struct TwoSAT
{
    int n;
    vector<int> G[maxn << 1];
    bool mark[maxn << 1];
    int S[maxn << 1], c;
    void init(int n)
    {
        this->n = n;
        for (int i = 0; i < (n << 1); i++) G[i].clear();
        clr(mark, 0);
    }
    bool dfs(int x)
    {
        if (mark[x ^ 1]) return false;
        if (mark[x]) return true;
        mark[x] = true;
        S[c++] = x;
        for (int i = 0; i < G[x].size(); i++)
        {
            if (!dfs(G[x][i])) return false;
            return true;
        }
    }
    //x = xval or y = yval
    void add_clause(int x, int xval, int y, int yval)
    {
        x = x << 1 + xval;
        y = y << 1 + yval;
        G[x ^ 1].pb(y);
        G[y ^ 1].pb(x);
    }
    bool solve()
    {
        for (int i = 0; i < (n << 1); i += 2)
            if (!mark[i] && !mark[i + 1])
            {
                c = 0;
                if (!dfs(i))
                {
                    while (c > 0) mark[S[--c]] = false;
                    if (!dfs(i + 1)) return false;
                }
            }
        return true;
    }
};
\end{lstlisting}
\clearpage\section{网络流}
\subsection{最大流}
\subsubsection{EdmondKarp}
\begin{lstlisting}
struct Edge
{
    int from, to, cap, flow;
    Edge(int u, int v, int c, int f): from(u), to(v), cap(c), flow(f) {}
};
struct EdmonsKarp           //时间复杂度O(v*E*E)
{
    int n, m;
    vector<Edge> edges;     //边数的两倍
    vector<int> G[maxn];    //邻接表，G[i][j]表示节点i的第j条边在e数组中的序号
    int a[maxn];            //起点到i的可改进量
    int p[maxn];            //最短路树上p的入弧编号
    void init(int n)
    {
        for (int i = 0; i < n; i++) G[i].clear();
        edges.clear();
    }
    void AddEdge(int from, int to, int cap)
    {
        edges.pb(Edge(from, to, cap, 0));
        edges.pb(Edge(to, from, 0, 0));  //反向弧
        m = edges.size();
        G[from].pb(m - 2);
        G[to].pb(m - 1);
    }
    int Maxflow(int s, int t)
    {
        int flow = 0;
        for (;;)
        {
            clr(a, 0);
            queue<int> q;
            q.push(s);
            a[s] = INF;
            while (!q.empty())
            {
                int x = q.front();
                q.pop();
                for (int i = 0; i < G[x].size(); i++)
                {
                    Edge& e = edges[G[x][i]];
                    if (!a[e.to] && e.cap > e.flow)
                    {
                        p[e.to] = G[x][i];
                        a[e.to] = min(a[x], e.cap - e.flow);
                        q.push(e.to);
                    }
                }
                if (a[t]) break;
            }
            if (!a[t]) break;
            for (int u = t; u != s; u = edges[p[u]].from)
            {
                edges[p[u]].flow += a[t];
                edges[p[u] ^ 1].flow -= a[t];
            }
            flow += a[t];
        }
        return flow;
    }
};
\end{lstlisting}
\subsubsection{Dinic}
\begin{lstlisting}
struct Edge
{
    int from, to, cap, flow;
    Edge(int u, int v, int c, int f): from(u), to(v), cap(c), flow(f) {}
};
struct Dinic
{
    int n, m, s, t;         //结点数，边数（包括反向弧），源点编号和汇点编号
    vector<Edge> edges;     //边表。edge[e]和edge[e^1]互为反向弧
    vector<int> G[maxn];    //邻接表，G[i][j]表示节点i的第j条边在e数组中的序号
    bool vis[maxn];         //BFS使用
    int d[maxn];            //从起点到i的距离
    int cur[maxn];          //当前弧下标
    void init(int n)
    {
        this->n = n;
        for (int i = 0; i < n; i++) G[i].clear();
        edges.clear();
    }
    void AddEdge(int from, int to, int cap)
    {
        edges.pb(Edge(from, to, cap, 0));
        edges.pb(Edge(to, from, 0, 0));
        m = edges.size();
        G[from].pb(m - 2);
        G[to].pb(m - 1);
    }
    bool BFS()
    {
        clr(vis, 0);
        clr(d, 0);
        queue<int> q;
        q.push(s);
        d[s] = 0;
        vis[s] = 1;
        while (!q.empty())
        {
            int x = q.front();
            q.pop();
            for (int i = 0; i < G[x].size(); i++)
            {
                Edge& e = edges[G[x][i]];
                if (!vis[e.to] && e.cap > e.flow)
                {
                    vis[e.to] = 1;
                    d[e.to] = d[x] + 1;
                    q.push(e.to);
                }
            }
        }
        return vis[t];
    }
    int DFS(int x, int a)
    {
        if (x == t || a == 0) return a;
        int flow = 0, f;
        for (int& i = cur[x]; i < G[x].size(); i++)
        {
            //从上次考虑的弧
            Edge& e = edges[G[x][i]];
            if (d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap - e.flow))) > 0)
            {
                e.flow += f;
                edges[G[x][i] ^ 1].flow -= f;
                flow += f;
                a -= f;
                if (a == 0) break;
            }
        }
        return flow;
    }
    int Maxflow(int s, int t)
    {
        this->s = s;
        this->t = t;
        int flow = 0;
        while (BFS())
        {
            clr(cur, 0);
            flow += DFS(s, INF);
        }
        return flow;
    }
};
\end{lstlisting}
\subsubsection{ISAP}
\begin{lstlisting}
struct Edge
{
    int from, to, cap, flow;
    Edge(int u, int v, int c, int f): from(u), to(v), cap(c), flow(f) {}
};
struct ISAP
{
    int n, m, s, t;         //结点数，边数（包括反向弧），源点编号和汇点编号
    vector<Edge> edges;     //边表。edges[e]和edges[e^1]互为反向弧
    vector<int> G[maxn];    //邻接表，G[i][j]表示结点i的第j条边在e数组中的序号
    bool vis[maxn];         //BFS使用
    int d[maxn];            //起点到i的距离
    int cur[maxn];          //当前弧下标
    int p[maxn];            //可增广路上的一条弧
    int num[maxn];          //距离标号计数
    void init(int n)
    {
        this->n = n;
        for (int i = 0; i < n; i++) G[i].clear();
        edges.clear();
    }
    void addedge(int from, int to, int cap)
    {
        edges.pb(Edge(from, to, cap, 0));
        edges.pb(Edge(to, from, 0, 0));
        int m = edges.size();
        G[from].pb(m - 2);
        G[to].pb(m - 1);
    }
    int Augumemt()
    {
        int x = t, a = INF;
        while (x != s)
        {
            Edge& e = edges[p[x]];
            a = min(a, e.cap - e.flow);
            x = edges[p[x]].from;
        }
        x = t;
        while (x != s)
        {
            edges[p[x]].flow += a;
            edges[p[x] ^ 1].flow -= a;
            x = edges[p[x]].from;
        }
        return a;
    }
    void BFS()
    {
        clr(vis, 0);
        clr(d, 0);
        queue<int> q;
        q.push(t);
        d[t] = 0;
        vis[t] = 1;
        while (!q.empty())
        {
            int x = q.front();
            q.pop();
            int len = G[x].size();
            for (int i = 0; i < len; i++)
            {
                Edge& e = edges[G[x][i]];
                if (!vis[e.from] && e.cap > e.flow)
                {
                    vis[e.from] = 1;
                    d[e.from] = d[x] + 1;
                    q.push(e.from);
                }
            }
        }
    }
    int Maxflow(int s, int t)
    {
        this->s = s;
        this->t = t;
        int flow = 0;
        BFS();
        clr(num, 0);
        for (int i = 0; i < n; i++) num[d[i]]++;
        int x = s;
        clr(cur, 0);
        while (d[s] < n)
        {
            if (x == t)
            {
                flow += Augumemt();
                x = s;
            }
            int ok = 0;
            for (int i = cur[x]; i < G[x].size(); i++)
            {
                Edge& e = edges[G[x][i]];
                if (e.cap > e.flow && d[x] == d[e.to] + 1)
                {
                    ok = 1;
                    p[e.to] = G[x][i];
                    cur[x] = i;
                    x = e.to;
                    break;
                }
            }
            if (!ok)    //Retreat
            {
                int m = n - 1;
                for (int i = 0; i < G[x].size(); i++)
                {
                    Edge& e = edges[G[x][i]];
                    if (e.cap > e.flow)
                        m = min(m, d[e.to]);
                }
                if (--num[d[x]] == 0) break; //gap优化
                num[d[x] = m + 1]++;
                cur[x] = 0;
                if (x != s) x = edges[p[x]].from;
            }
        }
        return flow;
    }
};
\end{lstlisting}
\subsection{最小费用最大流}
\begin{lstlisting}
struct Edge
{
    int from, to, cap, flow, cost;
    Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w) {}
};

struct MCMF
{
    int n, m;
    vector<Edge> edges;
    vector<int> G[maxn];
    int inq[maxn];      //是否在队列中
    int d[maxn];        //bellmanford
    int p[maxn];        //上一条弧
    int a[maxn];        //可改进量
    void init(int n)
    {
        this-> n = n;
        for (int i = 0; i < n; i++) G[i].clear();
        edges.clear();
    }
    void AddEdge(int from, int to, int cap, int cost)
    {
        edges.pb(Edge(from, to, cap, 0, cost));
        edges.pb(Edge(to, from, 0, 0, -cost));
        m = edges.size();
        G[from].pb(m - 2);
        G[to].pb(m - 1);
    }
    bool BellmanFord(int s, int t, int& flow, ll& cost)
    {
        for (int i = 0; i < n; i++) d[i] = INF;
        clr(inq, 0);
        d[s] = 0;
        inq[s] = 1;
        p[s] = 0;
        a[s] = INF;
        queue<int> q;
        q.push(s);
        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            inq[u] = 0;
            for (int i = 0; i < G[u].size(); i++)
            {
                Edge& e = edges[G[u][i]];
                if (e.cap > e.flow && d[e.to] > d[u] + e.cost)
                {
                    d[e.to] = d[u] + e.cost;
                    p[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if (!inq[e.to])
                    {
                        q.push(e.to);
                        inq[e.to] = 1;
                    }
                }
            }
        }
        if (d[t] == INF) return false;   // 当没有可增广的路时退出
        flow += a[t];
        cost += (ll)d[t] * (ll)a[t];
        for (int u = t; u != s; u = edges[p[u]].from)
        {
            edges[p[u]].flow += a[t];
            edges[p[u] ^ 1].flow -= a[t];
        }
        return true;
    }
    int MincostMaxflow(int s, int t, ll& cost)
    {
        int flow = 0;
        cost = 0;
        while (BellmanFord(s, t, flow, cost));
        return flow;
    }
};
\end{lstlisting}
\clearpage\section{计算几何}
\subsection{基本函数}
\begin{lstlisting}
#define eps 1e-8
#define pi M_PI
#define zero(x) ((fabs(x)<eps?1:0))
#define sgn(x) (fabs(x)<eps?0:((x)<0?-1:1))
#define mp make_pair
#define X first
#define Y second
struct point
{
    double x, y;
    point(double a = 0, double b = 0)
    {
        x = a;
        y = b;
    }
    point operator - (const point& b) const
    {
        return point(x - b.x, y - b.y);
    }
    point operator + (const point &b) const
    {
        return point(x + b.x, y + b.y);
    }
    // 两点是否重合
    bool operator == (point& b)
    {
        return zero(x - b.x) && zero(y - b.y);
    }
    // 点积(以原点为基准)
    double operator * (const point &b) const
    {
        return x * b.x + y * b.y;
    }
    // 叉积(以原点为基准)
    double operator ^ (const point &b) const
    {
        return x * b.y - y * b.x;
    }
    // 绕P点逆时针旋转a弧度后的点
    point rotate(point b, double a)
    {
        double dx, dy;
        (*this - b).split(dx, dy);
        double tx = dx * cos(a) - dy * sin(a);
        double ty = dx * sin(a) + dy * cos(a);
        return point(tx, ty) + b;
    }
    // 点坐标分别赋值到a和b
    void split(double &a, double &b)
    {
        a = x;
        b = y;
    }
};
struct line
{
    point s, e;
    line() {}
    line(point ss, point ee)
    {
        s = ss;
        e = ee;
    }
};
\end{lstlisting}
\subsection{位置关系}
\subsubsection{两点间距离}
\begin{lstlisting}
double dist(point a, point b)
{
    return sqrt((a - b) * (a - b));
}
\end{lstlisting}
\subsubsection{直线与直线的交点}
\begin{lstlisting}
// <0, *> 表示重合; <1, *> 表示平行; <2, P> 表示交点是P;
pair<int, point> spoint(line l1, line l2)
{
    point res = l1.s;
    if (sgn((l1.s - l1.e) ^ (l2.s - l2.e)) == 0)
        return mp(sgn((l1.s - l2.e) ^ (l2.s - l2.e)) != 0, res);
    double t = ((l1.s - l2.s) ^ (l2.s - l2.e)) / ((l1.s - l1.e) ^ (l2.s - l2.e));
    res.x += (l1.e.x - l1.s.x) * t;
    res.y += (l1.e.y - l1.s.y) * t;
    return mp(2, res);
}
\end{lstlisting}
\subsubsection{判断线段与线段相交}
\begin{lstlisting}
bool segxseg(line l1, line l2)
{
    return
        max(l1.s.x, l1.e.x) >= min(l2.s.x, l2.e.x) &&
        max(l2.s.x, l2.e.x) >= min(l1.s.x, l1.e.x) &&
        max(l1.s.y, l1.e.y) >= min(l2.s.y, l2.e.y) &&
        max(l2.s.y, l2.e.y) >= min(l1.s.y, l1.e.y) &&
        sgn((l2.s - l1.e) ^ (l1.s - l1.e)) * sgn((l2.e-l1.e) ^ (l1.s - l1.e)) <= 0 &&
        sgn((l1.s - l2.e) ^ (l2.s - l2.e)) * sgn((l1.e-l2.e) ^ (l2.s - l2.e)) <= 0;
}
\end{lstlisting}
\subsubsection{判断线段与直线相交}
\begin{lstlisting}
bool segxline(line l1, line l2)
{
    return sgn((l2.s - l1.e) ^ (l1.s - l1.e)) * sgn((l2.e-l1.e) ^ (l1.s - l1.e)) <= 0;
}
\end{lstlisting}
\subsubsection{点到直线距离}
\begin{lstlisting}
point pointtoline(point P, line L)
{
    point res;
    double t = ((P - L.s) * (L.e-L.s)) / ((L.e-L.s) * (L.e-L.s));
    res.x = L.s.x + (L.e.x - L.s.x) * t;
    res.y = L.s.y + (L.e.y - L.s.y) * t;
    return dist(P, res);
}
\end{lstlisting}
\subsubsection{点到线段距离}
\begin{lstlisting}
point pointtosegment(point p, line l)
{
    point res;
    double t = ((p - l.s) * (l.e-l.s)) / ((l.e-l.s) * (l.e-l.s));
    if (t >= 0 && t <= 1)
    {
        res.x = l.s.x + (l.e.x - l.s.x) * t;
        res.y = l.s.y + (l.e.y - l.s.y) * t;
    }
    else res = dist(p, l.s) < dist(p, l.e) ? l.s : l.e;
    return res;
}
\end{lstlisting}
\subsubsection{点在线段上}
\begin{lstlisting}
bool PointOnSeg(point p, line l)
{
    return
        sgn((l.s - p) ^ (l.e-p)) == 0 &&
        sgn((p.x - l.s.x) * (p.x - l.e.x)) <= 0 &&
        sgn((p.y - l.s.y) * (p.y - l.e.y)) <= 0;
}
\end{lstlisting}
\subsection{多边形}
\subsubsection{多边形面积}
\begin{lstlisting}
double area(point p[], int n)
{
    double res = 0;
    for (int i = 0; i < n; i++)
        res += (p[i] ^ p[(i + 1) % n]) / 2;
    return fabs(res);
}
\end{lstlisting}
\subsubsection{点在凸多边形内}
\begin{lstlisting}
// 点形成一个凸包, 而且按逆时针排序(如果是顺时针把里面的<0改为>0)
// 点的编号 : [0,n)
// -1 : 点在凸多边形外
// 0  : 点在凸多边形边界上
// 1  : 点在凸多边形内
int PointInConvex(point a, point p[], int n)
{
    for (int i = 0; i < n; i++)
    {
        if (sgn((p[i] - a) ^ (p[(i + 1) % n] - a)) < 0)
            return -1;
        else if (PointOnSeg(a, line(p[i], p[(i + 1) % n])))
            return 0;
    }
    return 1;
}
\end{lstlisting}
\subsubsection{点在任意多边形内}
\begin{lstlisting}
// 射线法,poly[]的顶点数要大于等于3,点的编号0~n-1
// -1 : 点在凸多边形外
// 0  : 点在凸多边形边界上
// 1  : 点在凸多边形内
int PointInPoly(point p, point poly[], int n)
{
    int cnt;
    line ray, side;
    cnt = 0;
    ray.s = p;
    ray.e.y = p.y;
    ray.e.x = -100000000000.0; // -INF,注意取值防止越界
    for (int i = 0; i < n; i++)
    {
        side.s = poly[i];
        side.e = poly[(i + 1) % n];
        if (PointOnSeg(p, side))return 0;
        //如果平行轴则不考虑
        if (sgn(side.s.y - side.e.y) == 0)
            continue;
        if (PointOnSeg(sid e.s, r ay))
        {
            if (sgn(side.s.y - side.e.y) > 0) cnt++;
        }
        else if (PointOnSeg(side.e, ray))
        {
            if (sgn(side.e.y - side.s.y) > 0) cnt++;
        }
        else if (segxseg(ray, side)) cnt++;
    }
    return cnt % 2 == 1 ? 1 : -1;
}
\end{lstlisting}
\subsubsection{判断凸多边形}
\begin{lstlisting}
//点可以是顺时针给出也可以是逆时针给出
//点的编号1~n-1
bool isconvex(point poly[], int n)
{
    bool s[3];
    set(s, 0);
    for (int i = 0; i < n; i++)
    {
        s[sgn((poly[(i + 1) % n] - poly[i]) ^ (poly[(i + 2) % n] - poly[i]) ) + 1] = 1;
        if (s[0] && s[2]) return 0;
    }
    return 1;
}
\end{lstlisting}
\subsubsection{小结}
\begin{lstlisting}
#include <stdlib.h>
#include <math.h>
#define MAXN 1000
#define offset 10000
#define eps 1e-8
#define zero(x) (((x)>0?(x):-(x))<eps)
#define _sign(x) ((x)>eps?1:((x)<-eps?2:0))
struct point
{
    double x, y;
};
struct line
{
    point a, b;
};

double xmult(point p1, point p2, point p0)
{
    return (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y);
}

//判定凸多边形,顶点按顺时针或逆时针给出,允许相邻边共线
int is_convex(int n, point* p)
{
    int i, s[3] = {1, 1, 1};
    for (i = 0; i < n && s[1] | s[2]; i++)
        s[_sign(xmult(p[(i + 1) % n], p[(i + 2) % n], p[i]))] = 0;
    return s[1] | s[2];
}

//判定凸多边形,顶点按顺时针或逆时针给出,不允许相邻边共线
int is_convex_v2(int n, point* p)
{
    int i, s[3] = {1, 1, 1};
    for (i = 0; i < n && s[0] && s[1] | s[2]; i++)
        s[_sign(xmult(p[(i + 1) % n], p[(i + 2) % n], p[i]))] = 0;
    return s[0] && s[1] | s[2];
}

//判点在凸多边形内或多边形边上,顶点按顺时针或逆时针给出
int inside_convex(point q, int n, point* p)
{
    int i, s[3] = {1, 1, 1};
    for (i = 0; i < n && s[1] | s[2]; i++)
        s[_sign(xmult(p[(i + 1) % n], q, p[i]))] = 0;
    return s[1] | s[2];
}

//判点在凸多边形内,顶点按顺时针或逆时针给出,在多边形边上返回0
int inside_convex_v2(point q, int n, point* p)
{
    int i, s[3] = {1, 1, 1};
    for (i = 0; i < n && s[0] && s[1] | s[2]; i++)
        s[_sign(xmult(p[(i + 1) % n], q, p[i]))] = 0;
    return s[0] && s[1] | s[2];
}

//判点在任意多边形内,顶点按顺时针或逆时针给出
//on_edge表示点在多边形边上时的返回值,offset为多边形坐标上限
int inside_polygon(point q, int n, point* p, int on_edge = 1)
{
    point q2;
    int i = 0, count;
    while (i < n)
        for (count = i = 0, q2.x = rand() + offset, q2.y = rand() + offset; i < n; i++)
            if (zero(xmult(q, p[i], p[(i + 1) % n])) && (p[i].x - q.x) * (p[(i + 1) % n].x - q.x) < eps && (p[i].y - q.y) * (p[(i + 1) % n].y - q.y) < eps)
                return on_edge;
            else if (zero(xmult(q, q2, p[i])))
                break;
            else if (xmult(q, p[i], q2)*xmult(q, p[(i + 1) % n], q2) < -eps && xmult(p[i], q, p[(i + 1) % n])*xmult(p[i], q2, p[(i + 1) % n]) < -eps)
                count++;
    return count & 1;
}

inline int opposite_side(point p1, point p2, point l1, point l2)
{
    return xmult(l1, p1, l2) * xmult(l1, p2, l2) < -eps;
}

inline int dot_online_in(point p, point l1, point l2)
{
    return zero(xmult(p, l1, l2)) && (l1.x - p.x) * (l2.x - p.x) < eps && (l1.y - p.y) * (l2.y - p.y) < eps;
}

//判线段在任意多边形内,顶点按顺时针或逆时针给出,与边界相交返回1
int inside_polygon(point l1, point l2, int n, point* p)
{
    point t[MAXN], tt;
    int i, j, k = 0;
    if (!inside_polygon(l1, n, p) || !inside_polygon(l2, n, p))
        return 0;
    for (i = 0; i < n; i++)
        if (opposite_side(l1, l2, p[i], p[(i + 1) % n]) && opposite_side(p[i], p[(i + 1) % n], l1, l2))
            return 0;
        else if (dot_online_in(l1, p[i], p[(i + 1) % n]))
            t[k++] = l1;
        else if (dot_online_in(l2, p[i], p[(i + 1) % n]))
            t[k++] = l2;
        else if (dot_online_in(p[i], l1, l2))
            t[k++] = p[i];
    for (i = 0; i < k; i++)
        for (j = i + 1; j < k; j++)
        {
            tt.x = (t[i].x + t[j].x) / 2;
            tt.y = (t[i].y + t[j].y) / 2;
            if (!inside_polygon(tt, n, p))
                return 0;
        }
    return 1;
}

point intersection(line u, line v)
{
    point ret = u.a;
    double t = ((u.a.x - v.a.x) * (v.a.y - v.b.y) - (u.a.y - v.a.y) * (v.a.x - v.b.x))
               / ((u.a.x - u.b.x) * (v.a.y - v.b.y) - (u.a.y - u.b.y) * (v.a.x - v.b.x));
    ret.x += (u.b.x - u.a.x) * t;
    ret.y += (u.b.y - u.a.y) * t;
    return ret;
}

point barycenter(point a, point b, point c)
{
    line u, v;
    u.a.x = (a.x + b.x) / 2;
    u.a.y = (a.y + b.y) / 2;
    u.b = c;
    v.a.x = (a.x + c.x) / 2;
    v.a.y = (a.y + c.y) / 2;
    v.b = b;
    return intersection(u, v);
}

//多边形重心
point barycenter(int n, point* p)
{
    point ret, t;
    double t1 = 0, t2;
    int i;
    ret.x = ret.y = 0;
    for (i = 1; i < n - 1; i++)
        if (fabs(t2 = xmult(p[0], p[i], p[i + 1])) > eps)
        {
            t = barycenter(p[0], p[i], p[i + 1]);
            ret.x += t.x * t2;
            ret.y += t.y * t2;
            t1 += t2;
        }
    if (fabs(t1) > eps)
        ret.x /= t1, ret.y /= t1;
    return ret;
}
\end{lstlisting}
\subsection{整数点问题}
\subsubsection{线段上整点个数}
\begin{lstlisting}
int OnSegment(line l)
{
    return __gcd(fabs(l.s.x - l.e.x), fabs(l.s.y - l.e.y)) + 1;
}
\end{lstlisting}
\subsubsection{多边形边上整点个数}
\begin{lstlisting}
int OnEdge(point p[], int n)
{
    int i, ret = 0;
    for (i = 0; i < n; i++)
        ret += __gcd(fabs(p[i].x - p[(i + 1) % n].x), fabs(p[i].y - p[(i + 1) % n].y));
    return ret;
}
\end{lstlisting}
\subsubsection{多边形内整点个数}
\begin{lstlisting}
int InSide(point p[], int n)
{
    int i, area = 0;
    for (i = 0; i < n; i++)
        area += p[(i + 1) % n].y * (p[i].x - p[(i + 2) % n].x);
    return (fabs(area) - OnEdge(n, p)) / 2 + 1;
}
\end{lstlisting}
\subsection{圆}
\subsubsection{过三点求圆心}
\begin{lstlisting}
point waixin(point a, point b, point c)
{
    double a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / 2;
    double a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / 2;
    double d = a1 * b2 - a2 * b1;
    return point(a.x + (c1 * b2 - c2 * b1) / d, a.y + (a1 * c2 - a2 * c1) / d);
}
\end{lstlisting}
\clearpage\section{字符串}
\subsection{KMP}
\begin{lstlisting}
// 返回y中x的个数
int ne[N];
void initkmp(char x[], int m)
{
    int i, j;
    j = ne[0] = -1;
    i = 0;
    while (i < m)
    {
        while (j != -1 && x[i] != x[j])
            j = ne[j];
        ne[++i] = ++j;
    }
}
int kmp(char x[], int m, char y[], int n)
{
    int i, j, ans;
    i = j = ans = 0;
    initkmp (x, m);
    while (i < n)
    {
        while (j != -1 && y[i] != x[j]) j = ne[j];
        i++;
        j++;
        if (j >= m)
        {
            ans++;
            j = ne[j];
        }
    }
    return ans;
}
\end{lstlisting}
\subsection{扩展KMP}
\begin{lstlisting}
//next[i]:x[i...m-1]与x[0...m-1]的最长公共前缀
//extend[i]:y[i...n-1]与x[0...m-1]的最长公共前缀
void pre_EKMP(char x[], int m)
{
    next[0] = m;
    int j = 0;
    while (j + 1 < m && x[j] == x[j + 1])j++;
    next[1] = j;
    int k = 1;
    for (int i = 2; i < m; i++)
    {
        int p = next[k] + k - 1;
        int L = next[i - k];
        if (i + L < p + 1)next[i] = L;
        else
        {
            j = max(0, p - i + 1);
            while (i + j < m && x[i + j] == x[j])j++;
            next[i] = j;
            k = i;
        }
    }
}
void EKMP(char x[], int m, char y[], int n)
{
    pre_EKMP(x, m, next);
    int j = 0;
    while (j < n && j < m && x[j] == y[j])j++;
    extend[0] = j;
    int k = 0;
    for (int i = 1; i < n; i++)
    {
        int p = extend[k] + k - 1;
        int L = next[i - k];
        if (i + L < p + 1)extend[i] = L;
        else
        {
            j = max(0, p - i + 1);
            while (i + j < n && j < m && y[i + j] == x[j])j++;
            extend[i] = j;
            k = i;
        }
    }
}
\end{lstlisting}
\subsection{Manacher最长回文子串}
\begin{lstlisting}
// O(n)求解最长回文子串
const int N = 1000100;
char s[N], str[N << 1];
int p[N << 1];
void Manacher(char s[], int &n)
{
    str[0] = '$';
    str[1] = '#';
    for (int i = 0; i < n; i++)
    {
        str[(i << 1) + 2] = s[i];
        str[(i << 1) + 3] = '#';
    }
    n = 2 * n + 2;
    str[n] = 0;
    int mx = 0, id;
    for (int i = 1; i < n; i++)
    {
        p[i] = mx > i ? min(p[2 * id - i], mx - i) : 1;
        for (; str[i - p[i]] == str[i + p[i]]; p[i]++);
        if (p[i] + i > mx)
        {
            mx = p[i] + i;
            id = i;
        }
    }
}
int solve(char s[])
{
    int n = strlen(s);
    Manacher(s, n);
    int res = 0;
    for (int i = 0; i < n; i++)
        res = max(res, p[i]);
    return res - 1;
}
\end{lstlisting}
\subsection{AC自动机}
\begin{lstlisting}
struct Trie
{
    int ch[maxnode][sigema_size];
    int val[maxnode];
    int f[maxnode];
    int sz;                                         //  结点总数
    Trie()
    {
        sz = 1;    //  初始时只有一个根结点
        clr (ch[0], 0, sizeof(ch[0]));
    }
    int idx(char c)
    {
        return c - 'a';    //  字符c的编号
    }
    //  插入字符串s，附加信息为v。注意v必须非0，因为0代表“本结点不是单词结点”
    void insert(char *s, int v)
    {
        int u = 0, n = strlen(s);
        for (int i = 0; i < n; i++)
        {
            int c = idx(s[i]);
            if (!ch[u][c])                          //  结点不存在
            {
                clr(ch[sz], 0);
                val[sz] = 0;                        //  中间结点的附加信息为0
                ch[u][c] = sz++;                    //  新建结点
            }
            u = ch[u][c];                           //  往下走
        }
        val[u] = v;                                 //  字符串最后一个字符的附加信息为v
    }
    //  查找字符串s，返回其附加信息
    int find(const char *s)
    {
        int u = 0, n = strlen(s);
        for (int i = 0; i < n; i++)
        {
            int c = idx(s[i]);
            if (!ch[u][c])
                return -1;
            u = ch[u][c];
        }
        return val[u];
    }
    //  删除字符串s
    void del(const char *s)
    {
        int u = 0, n = strlen(s);
        for (int i = 0; i < n; i++)
        {
            int c = idx(s[i]);
            if (!ch[u][c])
                return;
            u = ch[u][c];
        }
        val[u] = 0;
    }
    int getFail()
    {
        queue<int> q;
        f[0] = 0;
        //  初始化队列
        for (int c = 0; c < sigma_size; c++)
        {
            int u = ch[0][c];
            if (u)
            {
                f[u] = 0;
                q.push(u);
                last[u] = 0;
            }
        }
        //  按BFS顺序计算失配函数
        while (!q.empty())
        {
            int r = q.front();
            q.pop();
            for (int c = 0; c < sigma_size; c++)
            {
                int u = ch[r][c];
                if (!u) continue;
                q.push(u);
                int v = f[r];
                while (v && !ch[v][c]) v = f[v];
                f[u] = ch[v][c];
                last[u] = val[f[u]] ? f[u] : last[f[u]];
            }
        }
    }
    //  在文本串T中找模版
    void find(char *T)
    {
        int n = strlen(T);
        int j = 0;                                  //  当前结点编号，初始为根结点
        for (int i = 0; i < n; i++)                 //  文本串当前指针
        {
            int c = idx(T[i]);
            while (j && !ch[j][c]) j = f[j];        //  顺着失配边走，直到可以匹配
            j = ch[j][c];
            if (val[j]) print(i, j);
            else if (last[j]) print(i, last[j])     //  找到了
            }
    }
    //  递归打印以结点j结尾的所有字符串
    void print(int j)
    {
        if (j)
        {
            printf("%d: %d\n", j, val[j]);
            print(last[j]);
        }
    }
};
\end{lstlisting}
\clearpage\section{其他}
\subsection{矩阵}
\subsubsection{矩阵快速幂}
\begin{lstlisting}
typedef vector <ll> vec;
typedef vector <vec> mat;
mat mul(mat &A, mat &B)
{
    mat C(A.size(), vec(B[0].size()));
    for (int i = 0; i < A.size(); i++)
        for (int k = 0; k < B.size(); k++)
            if (A[i][k]) // 对稀疏矩阵的优化
                for (int j = 0; j < B[0].size(); j++)
                    C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % mod;
    return C;
}
mat Pow (mat A, ll n)
{
    mat B(A.size(), vec(A.size()));
    for (int i = 0; i < A.size(); i++)
        B[i][i] = 1;
    for (; n; n >>= 1, A = mul(A, A))
        if (n & 1) B = mul(B, A);
    return B;
}
\end{lstlisting}
\subsubsection{高斯消元}
\begin{lstlisting}
void gauss()
{
    int now = 1, to;
    double t;
    for (int i = 1; i <= n; i++) {
        /*for (to = now; !a[to][i] && to <= n; to++);
        //做除法时减小误差，可不写
        if (to != now)
            for (int j = 1; j <= n + 1; j++)
                swap(a[to][j], a[now][j]);*/
        t = a[now][i];
        for (int j = 1; j <= n + 1; j++)
            a[now][j] /= t;
        for (int j = 1; j <= n; j++)
            if (j != now) {
                t = a[j][i];
                for (int k = 1; k <= n + 1; k++)
                    a[j][k] -= t * a[now][k];
            }
        now++;
    }
}

\end{lstlisting}
求线性基
\begin{lstlisting}
for (int i = 1; i <= m; i++)
    for (int j = 63; j >= 0; j--)
        if ((a[i] >> j) & 1) {
            if (!ins[j]) {
                ins[j] = a[i]; break;
            }
            else a[i] ^= ins[j];
        }
\end{lstlisting}
\subsection{离散化}
\begin{lstlisting}
\end{lstlisting}
若一些数据本身很大，无法作为下标储存，且数据的作用只和其相对大小有关时，可以将数据进行离散化。
\begin{lstlisting}
// B为A的副本。
sort(B, B + n);
int size = unqiue(B, B + n) - B; // size为离散化后元素的个数。
for (int i = 0; i < n; i++)
    A[i] = lower_bound(B, B + size, A[i]) - B + 1; // 离散化
\end{lstlisting}
\subsection{莫队算法}
\begin{lstlisting}
\end{lstlisting}
莫队算法,可以解决一类静态,离线区间查询问题。分成 $\sqrt{x}$ 块,分块排序。
\begin{lstlisting}
struct query
{
    int L, R, id;
} node[maxn];
bool cmp(query a, query b)
{
    if (a.L / unit != b.L / unit)
        return a.L / unit < b.L / unit;
    else
        return a.R < b.R;
}
void solve()
{
    tmp = 0;
    clr(num, 0);
    clr(ans, 0);
    int L = 1;
    int R = 0;
    for (int i = 0; i < m; i++)
    {
        while (node[i].L < L) add(a[--L]);
        while (node[i].L > L) del(a[L++]);
        while (node[i].R < R) del(a[R--]);
        while (node[i].R > R) add(a[++R]);
        ans[node[i].id] = tmp;
    }
}
\end{lstlisting}
\subsection{输入输出外挂}
\begin{lstlisting}
// 适用于正负整数
template <class T>
inline bool scan_d(T &ret)
{
    char c;
    int sgn;
    if (c = getchar(), c == EOF) return 0; //EOF
    while (c != '-' && (c < '0' || c > '9')) c = getchar();
    sgn = (c == '-') ? -1 : 1;
    ret = (c == '-') ? 0 : (c - '0');
    while (c = getchar(), c >= '0' && c <= '9') ret = ret * 10 + (c - '0');
    ret *= sgn;
    return 1;
}
inline void out(int x)
{
    if (x > 9) out(x / 10);
    putchar(x % 10 + '0');
}
\end{lstlisting}

\end{document}
